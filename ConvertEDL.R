#  ConvertEDL.R
#
# $Id: ConvertEDL.R,v 1.13 2014/08/03 00:11:47 david Exp $
#
#  R script that reads in an EDL file and converts it into a
#  set of R data.frames/matrix aka rtdf format.
#  EDL is a text format generated by the 93K.  HPUX based
#  93K testers are not always able to generate stdf files,
#  but can generate the EDL versions.
#
# Copyright (C) 2006-2014 David Gattrell
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#  David.Gattrell
#  @
#  gmail.com
# 
#-------------------------------------------------------------------
#  LotInfoFrame
#      LotInfoFrame[[index,"lotid"]]
#                         ,"sublotid"]]
#                         ,"start_t"]]
#                         ,"program"]]
#                         ,"tester_type"]]
#                         ,"tester_id"]]
#                         ,"handler"]]
#  HbinInfoFrame  (optional)
#      HbinInfoFrame[[index,"hbin_num"]]
#                          ,"hbin_cnt"]]
#                          ,"hbin_pf"]]
#                          ,"hbin_nam"]]
#  SbinInfoFrame  (optional)
#      SbinInfoFrame[[index,"sbin_num"]]
#                          ,"sbin_cnt"]]
#                          ,"sbin_pf"]]
#                          ,"sbin_nam"]]
#  WaferInfoFrame  (optional)
#      WaferInfoFrame[[index,"wafr_siz"]]
#                           ,"die_ht"]]
#                           ,"die_wid"]]
#                           ,"wf_units"]]
#                           ,"wf_flat"]]
#                           ,"center_x"]]
#                           ,"center_y"]]
#                           ,"pos_x"]]
#                           ,"pos_y"]]
#  WafersFrame  (optional)
#      WafersFrame[[index,"wafer_id"]]
#                        ,"start_t"]]
#                        ,"finish_t"]]
#                        ,"part_cnt"]]
#                        ,"good_cnt"]]
#  DevicesFrame
#      DevicesFrame[[index,"devnum"]]
#                         ,"temp"]]
#                         ,"x_coord"]]
#                         ,"y_coord"]]
#                         ,"wafer_index"]]
#                         ,"soft_bin"]]
#                         ,"hard_bin"]]
#                         ,"testtime"]]
#                         ,"site"]]
#  ParametersFrame
#      ParametersFrame[[index,"testnum"]]
#                            ,"testname"]]
#                            ,"scaler"]]
#                            ,"units"]]
#                            ,"ll"]]
#                            ,"ul"]]
#                            ,plot_ll"]]
#                            ,plot_ul"]]
#  TSRFrame
#      TSRFrame[[index,"testnum"]]
#                     ,"testname"]]
#                     ,"test_typ"]]
#                     ,"exec_cnt"]]
#                     ,"fail_cnt"]]
#                     ,"fixed_exec_cnt"]]
#                     ,"fixed_fail_cnt"]]
#  ResultsMatrix
#      rows = devices
#      cols = parameters
#
#--------------------------------------------------------------

# namespace for the function... main function Global variables and local functions
#-------------------------------------------------------
if(exists(".ConvertEDL.env")) rm(.ConvertEDL.env) 
.ConvertEDL.env <- new.env()

assign("Timestamp1",0.0,envir=.ConvertEDL.env)      # timer to suppress prints to screen to >5sec

assign("Device_count",0,envir=.ConvertEDL.env)		# number of devices processed (PIR/PRR records)
assign("Open_site",rep(0,32),envir=.ConvertEDL.env)		# which Device index is for which site
assign("Parameter_count",0,envir=.ConvertEDL.env)	# number of tests processed (PTR/FTR/MPR*pins records)
assign("Wafer_count",0,envir=.ConvertEDL.env)		# number of wafers processed (WIR/WRR records)

assign("Hbin_count",0,envir=.ConvertEDL.env)		# number of Hard bins processed (HBR records)
assign("Sbin_count",0,envir=.ConvertEDL.env)		# number of Soft bins processed (SBR records)
assign("Previous_param_i",0,envir=.ConvertEDL.env)  # the ParametersFrame index from the previous PTR/FTR/MPR
assign("Good_guesses",0,envir=.ConvertEDL.env)		# how often Previous_param_i+1 worked

assign("LotInfoFrame",data.frame(rbind(
		list( lotid="", sublotid="",
                start_t=NaN, program="",
                tester_type="", tester_id="",
                handler="")
		)),envir=.ConvertEDL.env)

assign("ResultsMatrix",array(NaN, dim=c(0,0)),envir=.ConvertEDL.env)

assign("WafersFrame",data.frame(rbind(
		list(wafer_id='', start_t=NaN,
					finish_t=NaN, part_cnt=NaN,
					good_cnt=NaN)
		)),envir=.ConvertEDL.env)

# due to speed issues, it is better to deal with vectors than data frames,
# so create the following vectors that duplicate data frame information
assign("Parameters_Names",NA,envir=.ConvertEDL.env)     # <<- as.character(ParametersFrame$testname)
assign("Parameters_testnum",NA,envir=.ConvertEDL.env)   # <<- as.integer(
assign("Parameters_scaler",NA,envir=.ConvertEDL.env)    # <<- as.integer(
assign("Parameters_units",NA,envir=.ConvertEDL.env)     # <<- as.character(
assign("Parameters_ll",NA,envir=.ConvertEDL.env)		# <<- as.numeric(
assign("Parameters_ul",NA,envir=.ConvertEDL.env)		# <<- as.numeric(
assign("Parameters_plot_ll",NA,envir=.ConvertEDL.env)	# <<- as.numeric(
assign("Parameters_plot_ul",NA,envir=.ConvertEDL.env)	# <<- as.numeric(

assign("Devices_part_id",NA,envir=.ConvertEDL.env)     # <<- as.character(DevicesFrame$part_id)
assign("Devices_temp",NA,envir=.ConvertEDL.env)        # <<- as.numeric(
assign("Devices_x_coord",NA,envir=.ConvertEDL.env)     # <<- as.integer(
assign("Devices_y_coord",NA,envir=.ConvertEDL.env)     # <<- as.integer(
assign("Devices_wafer_index",NA,envir=.ConvertEDL.env) # <<- as.integer(
assign("Devices_soft_bin",NA,envir=.ConvertEDL.env)    # <<- as.integer(
assign("Devices_hard_bin",NA,envir=.ConvertEDL.env)	   # <<- as.integer(
assign("Devices_testtime",NA,envir=.ConvertEDL.env)	   # <<- as.numeric(
assign("Devices_site",NA,envir=.ConvertEDL.env)		   # <<- as.numeric(


##########################################################################
ConvertEDL <- function(edl_name="",rtdf_name="",auto_93k=TRUE,
					use_Pins_used=TRUE,edl_dir="") {
    # edl_name - name of edl formatted file to convert to rtdf format,
	#            this can be gzipped
    # rtdf_name - name to give to rtdf formatted file
    # auto_93k  - try to auto fix broken limits... ll = -1*ul, ul= -1*ll
	# use_Pins_used - If "Pin Results" section doesn't have pin names,
	#			 use the names from the "Pins used" line, otherwise
	#			 use no_pin1, no_pin2, no_pin3, ...
	# edl_dir - if edl file is in a different directory, this is the
	#			 absolute path to that directory
    #---------------------------------------------

    timestamp0 = proc.time()
    timestamp0 = timestamp0[3]  # start time
    Timestamp1 <<- timestamp0   # time since last screen write


	LotInfoFrame[["lotid"]] <<- ""
	LotInfoFrame[["sublotid"]] <<- ""
	LotInfoFrame[["start_t"]] <<- NaN
	LotInfoFrame[["program"]] <<- ""
	LotInfoFrame[["tester_type"]] <<- ""
	LotInfoFrame[["tester_id"]] <<- ""
	LotInfoFrame[["handler"]] <<- ""

	Device_count <<- 0
	Open_site <<- rep(0,32)
    Parameter_count <<- 0
	Parameters_Names <<- NA
    Wafer_count <<- 0
    #Hbin_count <<- 0
    #Sbin_count <<- 0
	ResultsMatrix <<- array(NaN, dim=c(0,0))

    Pin_names <<- NA

	part_id = ""

	# reset variables
	testnameA = ""
	testnameB = ""
	testnameC = ""
	pat_label = ""
	tnum = 0
	units=""
	scaler=1
	scale_p10=0		# 10^0 = 1
	lo_limit=NaN
	hi_limit=NaN
	valid_value = FALSE


    # if filenames not defined, prompt for them
    #------------------------------------------
    if (edl_name == "") {
        edl_name <- readline("Enter the name of the EDL file to read: ")
    }

    if (rtdf_name == "") {
        rtdf_name <- readline("Enter the name of the Rdata file to write: ")
    }


    # open edl file for reading...
    # suck whole file into memory
    #---------------------------------------
	if (edl_dir != "") {
		my_dir = getwd()
		setwd(edl_dir)
	}
    #EDL <- gzfile(edl_name,"r")
    #Edl <- readLines(EDL)
    EDL <- gzfile(edl_name)
    Edl <- readLines(EDL)
    close(EDL)
	if (edl_dir != "")  setwd(my_dir)
	lines <- length(Edl)
	

	# options(warn=2)
	# options(error=recover)


	# parse EDL lines...
	#--------------------------
	in_header=TRUE
	in_testsuite=FALSE
	in_pinresults=FALSE
	for (line in 1:lines) {
        timestamp2 = proc.time()
        timestamp2 = timestamp2[3]
        if (timestamp2>(Timestamp1+5.0)) {
			Timestamp1 <<- timestamp2
            pct = 100.0 * line / lines
            cat(sprintf("processing Device %d ... ",Device_count))
            cat(sprintf(" %.1f%% through file \n",pct))
        }
		#if(nchar(Edl[line])<2) {
		#	# blank line...
		#	if(!in_pinresults) {
		#		next
		#	}
		#} ... above didn't speed things up.
		if (in_header) {
			# HEADER PART
			#===========================================================
			# just look at lines that are --> Assign: field = "string"
			# or Test program .... lines
			if (substr(Edl[line],1,8)=="Assign: ") {
				tmp = Edl[line]
				# mu of EG4090 causes issues in linux? add useBytes=TRUE
				temp = sub("^Assign: ([^[:space:]]+) = \"(.+)","\\1\n\\2",tmp,
						useBytes=TRUE)
				temp = strsplit(temp,"\n")
				field = temp[[1]][1]
				string = temp[[1]][2]
				# remove trailing quote if present
				# some bad applicat's put <cr> just before " at end of line,
				# so it becomes 2 separate lines
				# and so cannot always expect a trailing double quote in sub()
				# above, remove it here if it is present
				string = sub("\"$","",string,useBytes=TRUE)
				#if (length(grep("wafer_id",Edl[line],useBytes=TRUE))>0) {
				#	browser()
				#}
				#if (field == "Lot_id") {
				#	browser()
				#}
				if (field == "package_id") {
					#in_header = FALSE
					part_id = sub("^Assign: package_id = \"(.+)\"","\\1",Edl[line])
					# line = line - 1  ... nope, for loop doesn't work this way!
				} else if (field == "PH_wafer_id")  { 
					wafer_id = string
			        Wafer_count <<- Wafer_count + 1
			        my_list = list(wafer_id=wafer_id, start_t=NaN,
			                finish_t=NaN,part_cnt=NaN,
			                good_cnt=NaN)
			        WafersFrame[Wafer_count,] <<- my_list
				} else {
					update_LotInfoFrame(field,string)
				}
			} else if (substr(Edl[line],1,13)=="Test program ") {
				tester_id = sub(".+ on ([^[:space:]]+) by.+","\\1",Edl[line])
				LotInfoFrame[["tester_id"]] <<- tester_id
				LotInfoFrame[["tester_type"]] <<- "93000"
			} else if (substr(Edl[line],1,20)=="Level die started on") {
				if (Wafer_count > 0) {
					start_t = sub(".+ on ([^[:space:]]+) at ([^[:space:]]+).*","\\1 \\2",Edl[line])
					WafersFrame[Wafer_count,"start_t"] <<- start_t
				}
			} else if (substr(Edl[line],1,19)=="Testflow started on") {
				in_header = FALSE
			} else if (substr(Edl[line],1,5)=="Site ") {
				in_header = FALSE
				add_device(part_id)

				#cat(sprintf(" part_id = %s, Device_count = %d \n",part_id,Device_count))

				my_site = as.integer(sub("^Site ([0-9]+):.*","\\1",Edl[line]))
				Devices_site[Device_count] <<- my_site  
				Open_site[my_site+1] <<- Device_count
				# if next letter is W, then get x,y coordinates...
				my_char = sub("^Site [0-9]+: ([A-Za-z]).*","\\1",Edl[line])
				if (my_char == "W") { 
					x_coord = sub("^Site [0-9]+: [A-Za-z]([-0-9]+),.*","\\1",Edl[line])
					y_coord = sub("^Site [0-9]+: [A-Za-z][-0-9]+,([-0-9]+).*","\\1",Edl[line])
					Devices_x_coord[Device_count] <<- x_coord
					Devices_y_coord[Device_count] <<- y_coord
					Devices_wafer_index[Device_count] <<- Wafer_count
					part_id = Device_count
					Devices_part_id[Device_count] <<- Device_count
				}
			}
		} else if(in_testsuite) {
			# TEST SUITE PART
			#===========================================================
			if (in_pinresults) {
				# ---- Pin Results ---- section
				#----------------------------------------------
				if (length(grep("^[:space:]*$",Edl[line]))>0) {
					in_pinresults=FALSE
				} else if(length(grep("PASSED|FAILED",Edl[line]))>0) {
					index = index + 1
					#temp = sub("([^[:space:]]*) (PASSED|FAILED)[:space:]+([^[:space:]]*)","\\1/\\3/",Edl[line])

					# kluge fix here... if pinname is long enough, then don't get whitespace as first char of
					# line and temp[] becomes shifted by one.  So if first char isn't whitespace, insert 
					# a space now...
					my_line = Edl[line]
					if(substr(my_line,1,1)!=" ")  my_line = paste(" ",my_line,sep="") 
					#temp = strsplit(Edl[line],"\\s+")[[1]]
					temp = strsplit(my_line,"\\s+")[[1]]

					if (flag<2) {
						# on first pin, determine if pinnames will be present
						flag = match("PASSED",temp)
						if (is.na(flag))  flag = match("FAILED",temp)
					}
					if (flag==2) {
						if(use_Pins_used) {
							if(index<=length(pinlist))  pinname = pinlist[index]
							else  pinname = paste("no_pin",sprintf("%d",index),sep="")
						} else {
							pinname = paste("no_pin",sprintf("%d",index),sep="")
						}
						#value = temp[3]	# what about P = 
						if (length(temp)<3) {
							if (temp[2]=="PASSED")  value = 0
							else value = 1
						} else if (temp[3]=="P")  value = temp[5]
						else if(substr(temp[3],1,1)=="[") {
							# really 2 tests!! how to deal with this?  :1 :2 appended to tname?
							multi=TRUE
							temp2 = strsplit(Edl[line],"\\[|\\]")[[1]]
							temp3 = strsplit(temp2[2],"\\s+")[[1]]
							value = temp3[1]
							if (length(temp3)>4)  value2 = temp3[4]
							else  value2 = temp3[3]
						} else  value = temp[3]
					} else {	# flag==3
						pinname = temp[2]
						if (length(temp)<4) {
							if (temp[3]=="PASSED")  value = 0
							else value = 1
						} else if (temp[4]=="P")  value = temp[6]
						else if(substr(temp[4],1,1)=="[") {
							# really 2 tests!! how to deal with this?  :1 :2 appended to tname?
							multi=TRUE
							temp2 = strsplit(Edl[line],"\\[|\\]")[[1]]
							temp3 = strsplit(temp2[2],"\\s+")[[1]]
							value = temp3[1]
							if (length(temp3)>4)  value2 = temp3[4]
							else  value2 = temp3[3]
						} else  value = temp[4]
					}
					if(multi) {
						if (do_testnameC)  test_txt = paste(testnameA,testnameB,testnameC,"/",pinname,":1",sep="")
						else  test_txt = paste(testnameA,testnameB,"/",pinname,":1",sep="")
					} else {
						if (do_testnameC)  test_txt = paste(testnameA,testnameB,testnameC,"/",pinname,sep="")
						else  test_txt = paste(testnameA,testnameB,"/",pinname,sep="")
					}
					result = as.numeric(value) * scaler
						
					# has this test been added to ParametersFrame yet?
				    if (Parameter_count>0) {
				        if (nchar(test_txt)<1) {
				             par_index = match(test_num,Parameters_testnum,nomatch=0)
				        } else {
							if ((Previous_param_i < Parameter_count) &&
									(test_txt==Parameters_Names[Previous_param_i+1])) {
								par_index = Previous_param_i+1
								Good_guesses <<- Good_guesses + 1
							} else {
								par_index = match(test_txt,Parameters_Names,nomatch=0)
							}
						}
				    } else {
				       par_index = 0
				    }
				    if (par_index<1) {
						Parameter_count <<- Parameter_count + 1
						par_index = Parameter_count

						Parameters_testnum[Parameter_count] <<- as.numeric(tnum)
            			if (nchar(test_txt)<1) {
            			    Parameters_Names[Parameter_count] <<- ''
            			} else {
            			    Parameters_Names[Parameter_count] <<- test_txt
            			}
            			Parameters_scaler[Parameter_count] <<- -1*scale_p10	# ie power of 10, 0 = value of 1
            			Parameters_units[Parameter_count] <<- units
						Parameters_ll[Parameter_count] <<- lo_limit
            			Parameters_ul[Parameter_count] <<- hi_limit
            			Parameters_plot_ll[Parameter_count] <<- NaN
            			Parameters_plot_ul[Parameter_count] <<- NaN

            			#Parameters_Names <<- as.character(ParametersFrame$testname)

            			# we added a new parameter, so we need to add
            			# a new column to Results Matrix...
            			#---------------------------------------------
            			if( sum(dim(ResultsMatrix))==0) {
							ResultsMatrix <- array(NaN,dim=c(0,1))
						} else if ((dim(ResultsMatrix)[1])<1) {
							cols = 1 + dim(ResultsMatrix)[2]
							ResultsMatrix <- array(NaN,dim=c(0,cols))
						} else {
							ResultsMatrix <<- cbind(ResultsMatrix,NaN)
						}
        			}

					device_count = Open_site[my_site+1]
            		ResultsMatrix[device_count,par_index] <<- result

					Previous_param_i <<- par_index

					if(multi) {
						# now do second test... ":2"...
						if (do_testnameC)  test_txt = paste(testnameA,testnameB,testnameC,"/",pinname,":2",sep="")
						else  test_txt = paste(testnameA,testnameB,"/",pinname,":2",sep="")
						result = as.numeric(value2) * scaler
							
						# has this test been added to ParametersFrame yet?
						if (Parameter_count>0) {
							if (nchar(test_txt)<1) {
								 par_index = match(test_num,Parameters_testnum,nomatch=0)
							} else {
								if ((Previous_param_i < Parameter_count) &&
										(test_txt==Parameters_Names[Previous_param_i+1])) {
									par_index = Previous_param_i+1
									Good_guesses <<- Good_guesses + 1
								} else {
									par_index = match(test_txt,Parameters_Names,nomatch=0)
								}
							}
						} else {
						   par_index = 0
						}
						if (par_index<1) {
							Parameter_count <<- Parameter_count + 1
							par_index = Parameter_count

							Parameters_testnum[Parameter_count] <<- as.numeric(tnum)
							if (nchar(test_txt)<1) {
								Parameters_Names[Parameter_count] <<- ''
							} else {
								Parameters_Names[Parameter_count] <<- test_txt
							}
							Parameters_scaler[Parameter_count] <<- -1*scale_p10	# ie power of 10, 0 = value of 1
							Parameters_units[Parameter_count] <<- units
							Parameters_ll[Parameter_count] <<- lo_limit
							Parameters_ul[Parameter_count] <<- hi_limit
							Parameters_plot_ll[Parameter_count] <<- NaN
							Parameters_plot_ul[Parameter_count] <<- NaN

							#Parameters_Names <<- as.character(ParametersFrame$testname)

							# we added a new parameter, so we need to add
							# a new column to Results Matrix...
							#---------------------------------------------
							if( sum(dim(ResultsMatrix))==0) {
								ResultsMatrix <- array(NaN,dim=c(0,1))
							} else if ((dim(ResultsMatrix)[1])<1) {
								cols = 1 + dim(ResultsMatrix)[2]
								ResultsMatrix <- array(NaN,dim=c(0,cols))
							} else {
								ResultsMatrix <<- cbind(ResultsMatrix,NaN)
							}
						}

						ResultsMatrix[device_count,par_index] <<- result

						Previous_param_i <<- par_index
					}
    			}
			} else if (substr(Edl[line],1,24)=="======== Ended Testsuite") {
				if (valid_value) {
					# case where no Pin Results list, but still a parametric test
					pinname=""
					if (do_testnameC)  test_txt = paste(testnameA,testnameB,testnameC,sep="")
					else  test_txt = paste(testnameA,testnameB,sep="")
					result = as.numeric(value) * scaler

					# has this test been added to ParametersFrame yet?
				    if (Parameter_count>0) {
				        if (nchar(test_txt)<1) {
				             par_index = match(test_num,Parameters_testnum,nomatch=0)
				        } else {
							if ((Previous_param_i < Parameter_count) &&
									(test_txt==Parameters_Names[Previous_param_i+1])) {
								par_index = Previous_param_i+1
								Good_guesses <<- Good_guesses + 1
							} else {
								par_index = match(test_txt,Parameters_Names,nomatch=0)
							}
						}
				    } else {
				       par_index = 0
				    }

				    if (par_index<1) {
						Parameter_count <<- Parameter_count + 1
						par_index = Parameter_count

						Parameters_testnum[Parameter_count] <<- as.numeric(tnum)
            			if (nchar(test_txt)<1) {
            			    Parameters_Names[Parameter_count] <<- ''
            			} else {
            			    Parameters_Names[Parameter_count] <<- test_txt
            			}
            			Parameters_scaler[Parameter_count] <<- -1*scale_p10	# ie power of 10, 0 = value of 1
            			Parameters_units[Parameter_count] <<- units
						Parameters_ll[Parameter_count] <<- lo_limit
            			Parameters_ul[Parameter_count] <<- hi_limit
            			Parameters_plot_ll[Parameter_count] <<- NaN
            			Parameters_plot_ul[Parameter_count] <<- NaN

            			#Parameters_Names <<- as.character(ParametersFrame$testname)

            			# we added a new parameter, so we need to add
            			# a new column to Results Matrix...
            			#---------------------------------------------
            			if( sum(dim(ResultsMatrix))==0) {
							ResultsMatrix <- array(NaN,dim=c(0,1))
						} else if ((dim(ResultsMatrix)[1])<1) {
							cols = 1 + dim(ResultsMatrix)[2]
							ResultsMatrix <- array(NaN,dim=c(0,cols))
						} else {
							ResultsMatrix <<- cbind(ResultsMatrix,NaN)
						}
        			}
					device_count = Open_site[my_site+1]
            		ResultsMatrix[device_count,par_index] <<- result

					Previous_param_i <<- par_index
				}

				in_testsuite=FALSE
				in_pinresults=FALSE

				# reset variables
				testnameA = ""
				testnameB = ""
				testnameC = ""
				tnum = 0
				units=""
				scaler=1
				scale_p10=0		# 10^0 = 1
				lo_limit=NaN
				hi_limit=NaN
				valid_value = FALSE
			} else if (substr(Edl[line],1,20)=="-------- Pin Results") {
				in_pinresults=TRUE
				valid_value=FALSE	# don't use Measured Value:
				flag=0
				multi=FALSE		# if multiple tests per pin per line
				index=0
				#units=""	# maybe not... if extract from limits line REVISIT
				#scaler=1	# maybe not... if extract from limits line REVISIT
			} else if (substr(Edl[line],1,9)=="-------- ") {
				units=""
				scaler=1
				scale_p10=0		# 10^0 = 1
				lo_limit=NaN
				hi_limit=NaN
				# subtests... extract testnameB
				temp = sub("^-------- ([^:]+).+",":\\1",Edl[line])
				if (do_testnameC) {
					if (length(grep("[lL]ow",temp))>0) {
						testnameC = " low"	
					} else {
						testnameC = " high"
					}
				} else {
					testnameB = temp	# ":" prepended in sub() command above...
            				#cat(sprintf("testnameB = %s \n", testnameB))
					if(length(grep(":Functional",testnameB)) > 0) {
						if (length(grep("PASSED",Edl[line]))>0)  result = 0
						else  result = 128
						test_txt = paste(testnameA,testnameB,"/",pat_label,sep="")
						
						# has this test been added to ParametersFrame yet?
					    if (Parameter_count>0) {
					        if (nchar(test_txt)<1) {
					             par_index = match(test_num,Parameters_testnum,nomatch=0)
					        } else {
								if ((Previous_param_i < Parameter_count) &&
										(test_txt==Parameters_Names[Previous_param_i+1])) {
									par_index = Previous_param_i+1
									Good_guesses <<- Good_guesses + 1
								} else {
									par_index = match(test_txt,Parameters_Names,nomatch=0)
								}
							}
					    } else {
					       par_index = 0
					    }
					    if (par_index<1) {
							Parameter_count <<- Parameter_count + 1
							par_index = Parameter_count
	
							Parameters_testnum[Parameter_count] <<- as.numeric(tnum)
	            			if (nchar(test_txt)<1) {
	            			    Parameters_Names[Parameter_count] <<- ''
	            			} else {
	            			    Parameters_Names[Parameter_count] <<- test_txt
	            			}
	            			Parameters_scaler[Parameter_count] <<- -1*scale_p10	# ie power of 10, 0 = value of 1
	            			Parameters_units[Parameter_count] <<- units
							Parameters_ll[Parameter_count] <<- lo_limit
	            			Parameters_ul[Parameter_count] <<- hi_limit
	            			Parameters_plot_ll[Parameter_count] <<- NaN
	            			Parameters_plot_ul[Parameter_count] <<- NaN
	
	            			#Parameters_Names <<- as.character(ParametersFrame$testname)
	
	            			# we added a new parameter, so we need to add
	            			# a new column to Results Matrix...
	            			#---------------------------------------------
							if( sum(dim(ResultsMatrix))==0) {
								ResultsMatrix <- array(NaN,dim=c(0,1))
							} else if ((dim(ResultsMatrix)[1])<1) {
								cols = 1 + dim(ResultsMatrix)[2]
								ResultsMatrix <- array(NaN,dim=c(0,cols))
							} else {
								ResultsMatrix <<- cbind(ResultsMatrix,NaN)
							}
	        			}
	
						device_count = Open_site[my_site+1]
	            		ResultsMatrix[device_count,par_index] <<- result
	
						Previous_param_i <<- par_index
						# REVISIT!!!!
					}
				}
			} else if (substr(Edl[line],1,13)=="Executed Test") {
				temp = sub("^Executed Test([^[:space:]]*) ([^[:space:]]*)","\\1 \\2",Edl[line])
				words = strsplit(temp," ")[[1]]
				if(words[2]=="continuity") {
					testnameB = ":Continuity"
					do_testnameC = TRUE
				} else if(words[2]=="leakage") {
					testnameB = ":Leakage" 
					do_testnameC = TRUE
				}
				i = which(words=="Site")
				if(length(i)>0 && i>0) {
					my_site = as.integer(sub(":$","",words[i+1]))
				} else
					my_site = 1
			} else if (substr(Edl[line],1,12)=="test_number ") {
				tnum = as.numeric(sub("^test_number : ([0-9]+)","\\1",Edl[line]))
			} else if (substr(Edl[line],1,10)=="Startlabel") {
				pat_label = sub("^Startlabel: (.*)","\\1",Edl[line])
			} else if (substr(Edl[line],1,11)=="Pins used: ") {
				temp = sub("^Pins used: ","",Edl[line])
				pinlist = strsplit(temp,",")[[1]]
			} else if (substr(Edl[line],1,15)=="Measured Value:") {
				temp = strsplit(Edl[line],"\\s+")[[1]]
				value = temp[3]
				valid_value = TRUE
			} else if (substr(Edl[line],1,15)=="Pass/Fail Limit") {
				temp = sub("^Pass/Fail Limit","",Edl[line])
				my_chars = strsplit(temp,"")[[1]]
				if (my_chars[1]=="s") {
					temp = strsplit(Edl[line],"\\[|\\]|\\(|\\)")[[1]]
					temp2 = strsplit(temp[2]," +")[[1]]
					if(nchar(temp2[1])<1)  temp2 = temp2[2:length(temp2)]
					if(length(temp2)>3) {
						units = temp2[4]
						my_chars = strsplit(units,"")[[1]]
						end = length(my_chars)
						my_scale = check_prefix(units)	
						if (is.finite(my_scale)) {
							scale_p10 = my_scale
							scaler = 10^(scale_p10)
							units = substr(units,2,end)	
						} else {
							scaler = 1
							scale_p10 = 0
						}
						lo_limit = as.numeric(temp2[1]) * scaler
						hi_limit = as.numeric(temp2[3]) * scaler
					} else {
						lo_limit = as.numeric(temp2[1])
						hi_limit = as.numeric(temp2[3])
						units = ""
						scaler = 1
						scale_p10 = 0
					}
					if(length(grep("Outside",Edl[line]))>0) {
						# Output DC High .... Outside means passed
						lo_limit = hi_limit
						hi_limit = NaN
					}
				} else {
					temp = sub("^Pass/Fail Limit:","",Edl[line])
					temp = sub("^[[:space:]]*","",temp)			# remove leading spaces
					words = strsplit(temp," +")[[1]]
					if (length(grep("Greater",words[2]))>0) {
						lo_limit = as.numeric(words[1])
						hi_limit = NaN
					} else if (length(grep("Greater",words[3]))>0) {
						units = words[2]
						lo_limit = as.numeric(words[1])
						hi_limit = NaN
					} else if (length(grep("Less",words[2]))>0) {
						hi_limit = as.numeric(words[1])
						lo_limit = NaN
					} else if (length(grep("Less",words[3]))>0) {
						units = words[2]
						hi_limit = as.numeric(words[1])
						lo_limit = NaN
					} else {
						# should not get here!
					}
					my_chars = strsplit(units,"")[[1]]
					end = length(my_chars)
					my_scale = check_prefix(units)	
					if (is.finite(my_scale)) {
						scale_p10 = my_scale
						scaler = 10^(scale_p10)
						units = paste(my_chars[2:end],sep="",collapse="")
					} else {
						scaler = 1
						scale_p10 = 0
					}
					lo_limit = lo_limit * scaler
					hi_limit = hi_limit * scaler
				}
			}
		} else {
			# DEVICE PART
			#===========================================================
			if (substr(Edl[line],1,26)=="======== Started Testsuite") {
				testnameA = sub("^======== Started Testsuite (.+) =+$","\\1",Edl[line])
				testnameB = ""
				testnameC = ""
				do_testnameC = FALSE
				pinlist = "no_pin"
				in_testsuite=TRUE
			} else if (substr(Edl[line],1,18)=="Assign: package_id") {
				part_id = sub("^Assign: package_id = \"(.+)\"","\\1",Edl[line])
				#add_device(part_id)
			} else if (length(grep("^Site [0-9]+:",Edl[line],useBytes=TRUE))>0) {
				#part_id = sub("^Assign: package_id = \"(.+)\"","\\1",raw_line)
				add_device(part_id)

				#cat(sprintf(" part_id = %s, Device_count = %d \n",part_id,Device_count))

				my_site = as.integer(sub("^Site ([0-9]+):.*","\\1",Edl[line]))
				Devices_site[Device_count] <<- my_site  
				Open_site[my_site+1] <<- Device_count
				# if next letter is W, then get x,y coordinates...
				my_char = sub("^Site [0-9]+: ([A-Za-z]).*","\\1",Edl[line])
				if (my_char == "W") { 
					x_coord = sub("^Site [0-9]+: [A-Za-z]([-0-9]+),.*","\\1",Edl[line])
					y_coord = sub("^Site [0-9]+: [A-Za-z][-0-9]+,([-0-9]+).*","\\1",Edl[line])
					Devices_x_coord[Device_count] <<- x_coord
					Devices_y_coord[Device_count] <<- y_coord
					Devices_wafer_index[Device_count] <<- Wafer_count
					part_id = Device_count
					Devices_part_id[Device_count] <<- Device_count
				}
			} else if (substr(Edl[line],1,20)=="Testflow ended after") {
				testtime = sub("^Testflow ended after ([^[:space:]]+).*","\\1",Edl[line])
				Devices_testtime[Device_count] <<- as.numeric(testtime) * 1000.0	# in msec    
			} else if (length(grep("^Site .+ has .+ Binned to bin",Edl[line],useBytes=TRUE))>0) {
				temp = sub("^Site (.+) has .+ Binned to bin ([0-9]+)\\(([0-9]+)\\)","\\1 \\2 \\3",Edl[line])
				temp = strsplit(temp," ")[[1]]
				my_site = as.integer(temp[1])
				device_count = Open_site[my_site+1]
				sbin = temp[2]
				hbin = temp[3]
				Devices_soft_bin[device_count] <<- as.integer(sbin)
				Devices_hard_bin[device_count] <<- as.integer(hbin)
			} else if (length(grep("^Site .+ Binned to bin",Edl[line],useBytes=TRUE))>0) { 
				temp = sub("^Site (.+) Binned to bin ([0-9]+)\\(([0-9]+)\\)","\\1 \\2 \\3",Edl[line])
				temp = strsplit(temp," ")[[1]]
				my_site = as.integer(temp[1])
				device_count = Open_site[my_site+1]
				sbin = temp[2]
				hbin = temp[3]
				Devices_soft_bin[device_count] <<- as.integer(sbin)
				Devices_hard_bin[device_count] <<- as.integer(hbin)
			}
		}
	}


    # resize from allocated size to used size,
	# also pack into Frame if needed
    #----------------------------------------------
    ResultsMatrix <<- ResultsMatrix[1:Device_count,]
	# above creates a vector if only 1 device instead of a matrix, so below fixes this.
	if(!is.matrix(ResultsMatrix)) {
		ResultsMatrix <<- matrix(data=ResultsMatrix,nrow=Device_count,ncol=Parameter_count)
	}

    #DevicesFrame <<- DevicesFrame[1:Device_count,]
    my_list = list(part_id="", temp=NaN,
                x_coord=NaN, y_coord=NaN,
                wafer_index=NaN,
                soft_bin=NaN, hard_bin=NaN,
                testtime=NaN)
    DevicesFrame <- data.frame(rbind(my_list))
    DevicesFrame[1:Device_count,"part_id"] <- Devices_part_id[1:Device_count]
    DevicesFrame[1:Device_count,"temp"] <- Devices_temp[1:Device_count]
    DevicesFrame[1:Device_count,"x_coord"] <- Devices_x_coord[1:Device_count]
    DevicesFrame[1:Device_count,"y_coord"] <- Devices_y_coord[1:Device_count]
    DevicesFrame[1:Device_count,"wafer_index"] <- Devices_wafer_index[1:Device_count]
    DevicesFrame[1:Device_count,"soft_bin"] <- Devices_soft_bin[1:Device_count]
    DevicesFrame[1:Device_count,"hard_bin"] <- Devices_hard_bin[1:Device_count]
    DevicesFrame[1:Device_count,"testtime"] <- Devices_testtime[1:Device_count]
    DevicesFrame[1:Device_count,"site"] <- Devices_site[1:Device_count]

	my_list = list(testnum=NaN, testname="",
	                scaler=NaN, units="",
	                ll=NaN, ul=NaN,
	                plot_ll=NaN, plot_ul=NaN)
	ParametersFrame <- data.frame(rbind(my_list))
	ParametersFrame[1:Parameter_count,"testnum"] <- Parameters_testnum[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"testname"] <- Parameters_Names[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"scaler"] <- Parameters_scaler[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"units"] <- Parameters_units[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"ll"] <- Parameters_ll[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"ul"] <- Parameters_ul[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"plot_ll"] <- Parameters_plot_ll[1:Parameter_count]
	ParametersFrame[1:Parameter_count,"plot_ul"] <- Parameters_plot_ul[1:Parameter_count]


    # fix SMAR test stupidities...
    # SMAR = software monkeys aren't reliable  :)
    #-----------------------------------------
    if(auto_93k) {
        max_params = dim(ParametersFrame)
        max_params = max_params[1]
        for (j in 1:max_params) {
            ll = ParametersFrame$ll[[j]]
            ul = ParametersFrame$ul[[j]]

			# find limits that are the wrong polarity and fix them
			#------------------------------------------------------
			results_vector = ResultsMatrix[,j]
            results_vector = results_vector[is.finite(results_vector)]
            med = median(results_vector)
            fix_it = FALSE
	    if( is.finite(med) ) {
               if((length(ll)>0) && is.finite(ll)) {
                   if( (med<ll) && (med<(-1.0*ll)) ) {
                       if(is.finite(ul)) {
                           if( med>(-1.0*ul) )  fix_it = TRUE
                       } else {
                           fix_it = TRUE
                       }
                   }
               } else if((length(ul)>0) && is.finite(ul)) {
                   if( (med>ul) && (med<(-1.0*ul)) )  {
                       fix_it=TRUE
                   }
               }
	    }
            if(fix_it) {
                ParametersFrame$ll[[j]] = -1.0*ul
                ParametersFrame$ul[[j]] = -1.0*ll
            }

			# find bogus LL's or UL's and remove them...
			# ie. if UL = 0.0 and UL is <LL, then it is bogus!
			#     if LL = 0.0 and LL is >UL, then it is bogus!
			#--------------------------------------------------
			if( (length(ll)>0) && (length(ul)>0) && is.finite(ll) && is.finite(ul) ) {
				if(ul<ll) {
					if(ul==0.0) {
						ParametersFrame$ul[[j]] = NaN
					} else if(ll==0.0) {
						ParametersFrame$ll[[j]] = NaN
					}
				}
			}

        }

    }



	# save Rtdf file
    #-----------------
    my_list = c("LotInfoFrame","ParametersFrame","DevicesFrame","ResultsMatrix")
	
    if (Wafer_count>0) {
        my_list[length(my_list)+1] = "WafersFrame"
        # if (Valid_WCR)  my_list[length(my_list)+1] = "WaferInfoFrame"
    }

    save(list=my_list, file=rtdf_name)


    timestamp9 = proc.time()
    timestamp9 = timestamp9[3] - timestamp0
    if (timestamp9<200.0) {
        cat(sprintf("Conversion Finished! \n processed %d Devices x %d Parameters in %.2f seconds\n",
                Device_count,Parameter_count,timestamp9))
    } else {
        cat(sprintf("Conversion Finished! \n processed %d Devices x %d Parameters in %.2f minutes\n",
                Device_count,Parameter_count,timestamp9/60.0))
    }


}


###############################################################################
check_prefix <- function(units) {

	my_chars = strsplit(units,"")[[1]]

	if(length(my_chars)>0) {
		if		(my_chars[1]=="T")	scale_p10 = 12
		else if (my_chars[1]=="G")	scale_p10 = 9
		else if (my_chars[1]=="M")	scale_p10 = 6
		else if (my_chars[1]=="K")	scale_p10 = 3
		else if (my_chars[1]=="k")	scale_p10 = 3
		else if (my_chars[1]=="m")	scale_p10 = -3
		else if (my_chars[1]=="u")	scale_p10 = -6
		else if (my_chars[1]=="n")	scale_p10 = -9
		else if (my_chars[1]=="p")	scale_p10 = -12
		else if (my_chars[1]=="f")	scale_p10 = -15
		else						scale_p10 = NA
	} else							scale_p10 = NA
		
	
	return( scale_p10 )
}



###############################################################################
update_LotInfoFrame <- function(field,string) {
	
	if (field == "Lot_id") {
		LotInfoFrame[["lotid"]] <<- string
	} else if (field == "SubLot_id") {
		LotInfoFrame[["sublotid"]] <<- string
	} else if (field == "Start_time") {
		# REVISIT need to convert string to correct format...
		# should be in seconds since 1970...

		if(nchar(string)==15) {
			year = as.integer(substr(string,1,4))
			month = as.integer(substr(string,5,6))
			date = as.integer(substr(string,7,8))
			hour = as.integer(substr(string,10,11))
			minute = as.integer(substr(string,12,13))
			second = as.integer(substr(string,14,15))

			unix_seconds = as.integer(ISOdatetime(year,month,date,hour,minute,second))
			LotInfoFrame[["start_t"]] <<- unix_seconds
		} else {
			LotInfoFrame[["start_t"]] <<- string
		}
	} else if (field == "Test_program") {
		# just want up to first white space...
		string = sub('([^[:space:]]+).*','\\1',string)
		LotInfoFrame[["program"]] <<- string
#	} else if (field == "Temperature") {
	}
}


###############################################################################
add_device <- function(part_id) {

	#part_id = sub("^Assign: package_id = \"(.+)\"","\\1",raw_line)

    Device_count <<- Device_count + 1
	
	if ( sum(dim(ResultsMatrix))==0) {
		Devices_part_id <<- part_id # <<- as.character(DevicesFrame$part_id)
		Devices_temp <<- NA         # <<- as.numeric(
		Devices_x_coord <<- NA      # <<- as.integer(
		Devices_y_coord <<- NA      # <<- as.integer(
		Devices_wafer_index <<- NA  # <<- as.integer(
		Devices_soft_bin <<- NA     # <<- as.integer(
		Devices_hard_bin <<- NA     # <<- as.integer(
		Devices_testtime <<- NA     # <<- as.numeric(
		Devices_site <<- NA			# <<- as.numeric(
            
        ResultsMatrix<<- array(NaN, dim=c(1,0))
	} else {
        # wait 5 devices before allocating in chunks to allow 
        # parameters frame length to stabilize a bit.
        if (Device_count>=5) {
            # allocate memory in bigger chunks less often 
            # to improve speed...
            chunk = 200
            if (Device_count==5) {
                Devices_part_id[5:chunk] <<- NA     # <<- as.character(DevicesFrame$part_id)
                Devices_temp[5:chunk] <<- NA        # <<- as.numeric(
                Devices_x_coord[5:chunk] <<- NA     # <<- as.integer(
                Devices_y_coord[5:chunk] <<- NA     # <<- as.integer(
                Devices_wafer_index[5:chunk] <<- NA # <<- as.integer(
                Devices_soft_bin[5:chunk] <<- NA    # <<- as.integer(
                Devices_hard_bin[5:chunk] <<- NA    # <<- as.integer(
                Devices_testtime[5:chunk] <<-NA     # <<- as.numeric(
                Devices_site[5:chunk] <<-NA			# <<- as.numeric(

                my_dims = dim(ResultsMatrix)
                ResultsMatrix<<- rbind(ResultsMatrix,matrix(NaN,nrow=chunk-4,
                                    ncol=my_dims[2]))
            } else {
                mod_d = Device_count %% chunk  # modulus
                if(mod_d==0) {
                    #DevicesFrame[(Device_count+1):(Device_count+chunk),] <<- my_list
                    Devices_part_id[(Device_count+1):(Device_count+chunk)] <<- NA   
                    Devices_temp[(Device_count+1):(Device_count+chunk)] <<- NA      
                    Devices_x_coord[(Device_count+1):(Device_count+chunk)] <<- NA   
                    Devices_y_coord[(Device_count+1):(Device_count+chunk)] <<- NA   
                    Devices_wafer_index[(Device_count+1):(Device_count+chunk)] <<- NA 
                    Devices_soft_bin[(Device_count+1):(Device_count+chunk)] <<- NA  
                    Devices_hard_bin[(Device_count+1):(Device_count+chunk)] <<- NA  
                    Devices_testtime[(Device_count+1):(Device_count+chunk)] <<-NA   
                    Devices_site[(Device_count+1):(Device_count+chunk)] <<-NA   

                    my_dims = dim(ResultsMatrix)
                    ResultsMatrix<<- rbind(ResultsMatrix,matrix(NaN,nrow=chunk,
                                    ncol=my_dims[2]))
                }
            }
            Devices_part_id[Device_count] <<- part_id  
        } else {
            #DevicesFrame[Device_count,] <<- my_list
            Devices_part_id[Device_count] <<- NA  
            Devices_temp[Device_count] <<- NA   
            Devices_x_coord[Device_count] <<- NA   
            Devices_y_coord[Device_count] <<- NA  
            Devices_wafer_index[Device_count] <<- NA
            Devices_soft_bin[Device_count] <<- NA  
            Devices_hard_bin[Device_count] <<- NA   
            Devices_testtime[Device_count] <<-NA  
            Devices_site[Device_count] <<-NA    

            ResultsMatrix<<- rbind(ResultsMatrix,NaN)
        }
		
	}
	
	Devices_part_id[Device_count] <<- part_id  
	Devices_temp[Device_count] <<- NaN   
	Devices_x_coord[Device_count] <<- NaN   
	Devices_y_coord[Device_count] <<- NaN   
	Devices_wafer_index[Device_count] <<- NaN
	Devices_soft_bin[Device_count] <<- NaN  
	Devices_hard_bin[Device_count] <<- NaN   
	Devices_testtime[Device_count] <<-NaN  
	Devices_site[Device_count] <<-NaN    
}



#############################################################################
#  copy local functions to the .ConvertEDL.env and remove them
#  from the global environment
#############################################################################
environment(check_prefix)<-.ConvertEDL.env
assign("check_prefix",check_prefix,envir=.ConvertEDL.env)
rm(check_prefix)

environment(update_LotInfoFrame)<-.ConvertEDL.env
assign("update_LotInfoFrame",update_LotInfoFrame,envir=.ConvertEDL.env)
rm(update_LotInfoFrame)

environment(add_device)<-.ConvertEDL.env
assign("add_device",add_device,envir=.ConvertEDL.env)
rm(add_device)



environment(ConvertEDL)<-.ConvertEDL.env

