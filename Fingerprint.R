#  Fingerprint.R
#
# $Id: Fingerprint.R,v 1.1 2013/09/01 23:46:33 david Exp $
#
#  R script compares one dataset to a reference dataset for a subset of tests and
#  tries to determine if the part_id's are scrambled, and if scrambled what they
#  should be.  This can be used to audit different pulls in an 1000hr HTOL or 
#  similar retests of the same group of parts where there is an opportunity
#  to mix up the parts at retest.
#
#  If you supply 2 reference datasets (where part_ids are correct/common), the
#  script will generate the testlist based on the tests with the best correlation
#  that are independent.  (r>0.95, x_corr<0.70), by default up to 12 tests.
#
# Copyright (C) 2012-2013 David Gattrell
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#  David.Gattrell
#  @
#  gmail.com
# 
#-------------------------------------------------------------------


Fingerprint <- function(rtdf_name="",ref_rtdf_name="",testlist="",out_rtdf_name="",
                        ref2_rtdf_name="",top=7,in_dir="",ref_dir="") {
    # rtdf_name - name of dataset file which we want to verify/unscramble part_ids
	#            if this is set to "" and ref and ref2 rtdf files are supplied,
	#            this script will just do the testlist generation
    # ref_rtdf_name - name to dataset file with correct part_id's 
    # testlist - array of parameter testname's that should be used to do
    #            the fingerprinting.  These should be tests with very good repeatability
    #            vs. part-to-part spread, and should be independent of each other.
    #            Example tests are things like pull-up or pull-down resistors,
    #            bandgap or regulator outputs, or opamp dcoffset measurements.
    #            This can be an empty string if you are supplying ref2_rtdf_name
    #            and letting this script determine good candidate tests for
    #            fingerprinting.
    # out_rtdf_name - the dataset file generated by this script, basically the exact
    #            same as the input "rtdf_name" file, but with the part_id's overwritten
    #            with the fingerprinted part_id's from the ref_rtdf_name file
    # ref2_rtdf_name - optional - if this is supplied, this script will first 
    #            compare the ref and ref2 datasets to build the testlist to a 
    #            maximum of "top" parameters, see below.  Tests are sorted from
	#			 highest to lowest correlation factor "r".  Tests must have an r of at
	#			 least 0.95.  Tests must also have a cross-correlation of <0.7 to other
	#            tests in the testlist.
	#            The testlist will also be written to a file "my_testlist.R" 
    # top - if ref2_rtdf_name is supplied, this sets an upper limit on the number
	#            of tests in the testlist.  7 is probably a good number to use.
	# in_dir - location of rtdf_name if it is not in working directory
	# ref_dir - location of ref/ref2 files if not in working directory
    #---------------------------------------------

# if building testlist from ref2 vs ref1...
verbose = 0	#  0: quiet
			# +1: print cross correlating tests
			# +2: print quantized tests


# read in the reference dataset
#------------------------------
if (nchar(ref_rtdf_name)<1) {
	ref_rtdf_name <- readline("Enter the name of your reference rtdf file: ")
}
if (ref_dir != "") {
	my_dir = getwd()
	setwd(ref_dir)
}
load(ref_rtdf_name)
Ref_ParametersFrame = ParametersFrame
Ref_DevicesFrame = DevicesFrame
Ref_ResultsMatrix = ResultsMatrix


# if 2nd ref dataset, then auto-generate testlist
#------------------------------------------------
if (nchar(ref2_rtdf_name)>0) {
	load(ref2_rtdf_name)
	Ref2_ParametersFrame = ParametersFrame
	Ref2_DevicesFrame = DevicesFrame
	Ref2_ResultsMatrix = ResultsMatrix

	devices = dim(Ref_ResultsMatrix)[1]
	parameters = dim(Ref_ResultsMatrix)[2]

	# build part_id xrefs and parameter xrefs
	ref1_part_ids = Ref_DevicesFrame[["part_id"]]
	ref2_part_ids = Ref2_DevicesFrame[["part_id"]]
	dev_xref1 = 1	# just creating variables here
	dev_xref2 = 1	# just creating variables here
	j=1
	for(i in 1:length(ref1_part_ids)) {
		part_id = ref1_part_ids[i]		
		index = match(part_id,ref2_part_ids,nomatch=NaN)
		if(is.finite(index)) {
			dev_xref1[j] = i
			dev_xref2[j] = index
			j = j + 1
		}
	}
	if(j<2) {
		# REVISIT
		# nasty message and bail out
	}
	ref1_tnames = Ref_ParametersFrame[["testname"]]
	ref2_tnames = Ref2_ParametersFrame[["testname"]]
	param_xref1 = 1	# just creating variables here
	param_xref2 = 1	# just creating variables here
	j=1		# index of xref vector
	for(i in 1:length(ref1_tnames)) {
		test_name = ref1_tnames[i]
		index = match(test_name,ref2_tnames,nomatch=NaN)
		if(is.finite(index)) {
			param_xref1[j] = i
			param_xref2[j] = index
			j = j + 1
		}
	}
	if(j<2) {
		# REVISIT
		# nasty message and bail out
	}

	# look at just shared part_ids & parameters
	xref1_ResultsMatrix = Ref_ResultsMatrix[dev_xref1,param_xref1]
	xref1_ParametersFrame = Ref_ParametersFrame[param_xref1,]
	xref2_ResultsMatrix = Ref2_ResultsMatrix[dev_xref2,param_xref2]

	corr_matrix = cor(xref1_ResultsMatrix,xref2_ResultsMatrix)
	corr_vector = diag(corr_matrix)

	# need to make NA's zeros for sort() to work properly
	corr_vector[which(!is.finite(corr_vector))] = 0

	# best tests are those closest in value to 1.000
	# sorted$x is the corr factor
	# sorted$ix is the index
	sorted = sort(corr_vector,decreasing=TRUE,index.return=TRUE)

	# how many tests with value >0.95?
	good_count = length(which(sorted$x>0.95))
	all_count = length(sorted$x)

	cat(sprintf("%d tests with corr >0.95 out of %d tests\n",
			good_count,all_count))
	if(good_count<5) {
		# REVISIT
		# nasty message and then bail
	}

	devices = length(dev_xref1)
	k=1
	my_testlist = "empty"
	my_comment = "# no comment"
	my_ixs = 0
	vq = (as.raw(verbose) & as.raw(1))>0
	vxc = (as.raw(verbose) & as.raw(2))>0


	for( i in 1:good_count) {

		my_testname = xref1_ParametersFrame[[sorted$ix[i],"testname"]]

		# check if heavily quantized...
		# expect >0.75*# of devices or 20, whichever is less
		# to be considered an acceptable test
		levels = length(unique(xref1_ResultsMatrix[,sorted$ix[i]]))
		if ((levels>20) || (levels>(0.75*devices))) {
			# if i>1, check cross correlation
			# want independent variables, so $x<0.75
			if(k>1) {
				cross_corr = max(abs(
							corr_matrix[sorted$ix[i],my_ixs]
							))
			} else {
				cross_corr = 0.0
			}
			if ((i<2) || (cross_corr<0.70)) {
				if(k<=top) {
					cat(sprintf("TEST %s works, corr %.3f, xcorr %.2f, count=%d\n",
							my_testname,sorted$x[i],cross_corr,k))
				}
				my_testlist[k] = my_testname
				my_comment[k] = sprintf("# corr %.3f, xcorr %.2f",sorted$x[i],cross_corr)
				my_ixs[k] = sorted$ix[i]
				k = k+1
			} else {
				if(vxc) cat(sprintf("....test %s cross correlates %.2f \n",
						my_testname,cross_corr))
			}

		} else {
			if (vq) cat(sprintf("....test %s too quantized\n",my_testname))
		}
	}

	# testlist now defined, dump it to a file...
	#--------------------------------------------
	if(k>1) {
		max_width = max(nchar(my_testlist))

		out_file = "my_testlist.R"
		my_string = "my_testlist = c(\n"
		cat(my_string,file=out_file)
		comma = ","
		for(i in 1:length(my_testlist)) {
			if(i==length(my_testlist))  comma = " "
			used_width = nchar(my_testlist[i])
			my_string = sprintf("    \"%s\" %s %s %s \n",my_testlist[i],
							comma,
							paste(rep(" ",max_width-used_width+1),sep="",collapse=""),
							my_comment[i])
			cat(my_string,file=out_file,append=TRUE)
		}

		my_string = "    )\n"
		cat(my_string,file=out_file,append=TRUE)
	}
	

	# if testlist hasn't been defined, use my_testlist
	#-------------------------------------------------
	if( (length(testlist)<2) && (nchar(testlist)<1) ) {
		testlist = my_testlist
	}
}
if (ref_dir != "")  setwd(my_dir)


# if an rtdf_name is supplied, then we want to finger print it...
#===============================================================
do_fingerprint = FALSE
if (nchar(rtdf_name)>0) {
	do_fingerprint = TRUE
	if( (length(testlist)<2) && (nchar(testlist)<1) ) {
		do_fingerprint = FALSE
		cat("No valid testlist to do fingerprinting!\n")
	}
}
if (do_fingerprint) {

	# read in the raw dataset
	#-----------------------
	if (in_dir != "") {
		my_dir = getwd()
		setwd(in_dir)
	}
	my_objs = load(rtdf_name)
	if (in_dir != "")  setwd(my_dir)
	Raw_DevicesFrame = DevicesFrame



	# initialize variables used in fingerprinting
	#--------------------------------------------
	test_count = length(testlist)
	if (test_count>top)  test_count = top	

	raw_part_count = dim(Raw_DevicesFrame)[1]
	ref_part_count = dim(Ref_DevicesFrame)[1]

	ref_idx = 0
	raw_idx = 0
	delta = array(NaN,dim=c(test_count,raw_part_count,ref_part_count))
	my_deltas = array(NaN,dim=c(raw_part_count,ref_part_count))
	my_maxes = array(NaN,dim=c(raw_part_count,ref_part_count))
	my_sums = array(NaN,dim=c(raw_part_count,ref_part_count))
	my_ok_flags = array(1,dim=c(raw_part_count,ref_part_count))
	per_raw_maxes = 0
	per_raw_sums = 0


	#cat("DEBUG: initializing done \n")

	# find ParameterFrame xrefs
	#--------------------------
	for (i in 1:test_count) {
		ref_idx[i] = match(testlist[i],Ref_ParametersFrame[["testname"]],nomatch=NaN)
		raw_idx[i] = match(testlist[i],ParametersFrame[["testname"]],nomatch=NaN)
		
		if(!is.finite(ref_idx[i]) || !is.finite(raw_idx[i])) {
			cat(sprintf("ERROR: could not find testname %s \n",testlist[i]))
		}
		
		# scale data from 0 to 1 (to give each test similar weighting)
		#-----------------------
		ref_data = Ref_ResultsMatrix[,ref_idx[i]]
		raw_data = ResultsMatrix[,raw_idx[i]]
		
		ref_data = ref_data - min(ref_data[is.finite(ref_data)])
		ref_data = ref_data / max(ref_data[is.finite(ref_data)])
		
		raw_data = raw_data - min(raw_data[is.finite(raw_data)])
		raw_data = raw_data / max(raw_data[is.finite(raw_data)])
		
		# compare values between each part in dataset 1 to each part in dataset 2
		#------------------------------------------------------------------------
		for (j in 1:raw_part_count) {
			for (k in 1:ref_part_count) {
				delta[i,j,k] = abs(raw_data[j] - ref_data[k])
			}
		}
	}

	#cat("DEBUG: delta matrix built\n")

	# get max and total error/delta from all fingerprint tests for each part vs. part
	#--------------------------------------------------------------------------------
	for (j in 1:raw_part_count) {
		for (k in 1:ref_part_count) {
			my_deltas = delta[,j,k]
			if(!is.finite(max(my_deltas))) {
				my_ok_flags[j,k] = 0
				my_deltas = my_deltas[is.finite(my_deltas)]
			}
			if(length(my_deltas)<1) {
				my_maxes[j,k] = 2
			} else {
				my_maxes[j,k] = max(my_deltas)
			}
		}
	}

	#cat("DEBUG: deltas calculated\n")

	#browser()

	# looking at reference parts for each raw part, 
	# find minimum of max errors, dump summary to screen
	#-------------------------------------------------------------
	for (j in 1:raw_part_count) {
		per_raw_maxes = my_maxes[j,]
		per_raw_oks = my_ok_flags[j,]
		
		k_max = which(per_raw_maxes==min(per_raw_maxes))
		k_ok = min(per_raw_oks)
		if(length(k_max)>1) {
			k_max = k_max[1]
		}
		sorted_maxes = sort(per_raw_maxes,decreasing=FALSE,index.return=TRUE)
		maxes_ix = sorted_maxes$ix
		
		ref_part_id = as.character(Ref_DevicesFrame[[maxes_ix[1],"part_id"]])
		my_string = sprintf("For part %2d, part_id %4s, best fit: part %2d partid %4s ",
				j,Raw_DevicesFrame[[j,"part_id"]],maxes_ix[1],ref_part_id)
		cat(my_string)
		my_string = sprintf("max=%.3f ",per_raw_maxes[maxes_ix[1]])
		cat(my_string)
		if( per_raw_maxes[k_max]>0.1 ) {
			my_string = "*** NOT A GREAT MATCH \n"
		} else if (!k_ok) {
			my_string = "*** MISSING DATA \n"
		} else {
			my_string = "\n"
		}
		cat(my_string)
		
		DevicesFrame[[j,"part_id"]] = ref_part_id
		
		# if there are other matches with a max<0.1, print those too...
		k=2
		while ((per_raw_maxes[maxes_ix[k]]<0.1) && (k<=ref_part_count)) {
			ref_part_id = as.character(Ref_DevicesFrame[[maxes_ix[k],"part_id"]])
			my_string = sprintf("                      alternate fit: part %2d partid %4s ",
					maxes_ix[k],ref_part_id)
			cat(my_string)
			my_string = sprintf("max=%.3f ",per_raw_maxes[maxes_ix[k]])
			cat(my_string)
			my_string = "\n"
			cat(my_string)
			k = k + 1
		}
	}


	# could also step through each reference part and find the raw part
	# that is the best match...
	# ... if all goes well, then these should line up with the above
	# matching, and there should be no duplicates
	#-------------------------------------------------------------------



	# save new rtdf file with correctly swapped part_id's
	#----------------------------------------------------
	save(list=my_objs,file=out_rtdf_name)

	}

}
